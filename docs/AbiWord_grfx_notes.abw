<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE abiword PUBLIC "-//ABISOURCE//DTD AWML 1.0 Strict//EN" "http://www.abisource.com/awml.dtd">
<abiword template="false" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xid-max="188" xmlns:dc="http://purl.org/dc/elements/1.1/" fileformat="1.1" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:awml="http://www.abisource.com/awml.dtd" xmlns="http://www.abisource.com/awml.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" props="dom-dir:ltr; document-footnote-restart-section:0; document-endnote-type:numeric; document-endnote-place-enddoc:1; document-endnote-initial:1; lang:en-GB; document-endnote-restart-section:0; document-footnote-restart-page:0; document-footnote-type:numeric; document-footnote-initial:1; document-endnote-place-endsection:0">
<!-- ======================================================================== -->
<!-- This file is an AbiWord document.                                        -->
<!-- AbiWord is a free, Open Source word processor.                           -->
<!-- More information about AbiWord is available at http://www.abisource.com/ -->
<!-- You should not edit this file by hand.                                   -->
<!-- ======================================================================== -->

<metadata>
<m key="dc.format">application/x-abiword</m>
<m key="abiword.generator">AbiWord</m>
</metadata>
<history version="105" edit-time="10434" last-saved="1102262959" uid="29d74b9e-4612-11d9-887d-a9f98fd0dbfb">
<version id="100" started="1102178093" uid="aefb5bd8-4628-11d9-887d-a9f98fd0dbfb" auto="0" top-xid="7"/>
<version id="105" started="1102262429" uid="050549f8-46d8-11d9-9c63-f453762cd5ad" auto="0" top-xid="183"/>
</history>
<styles>
<s followedby="Normal" name="Heading 1" basedon="Normal" type="P" props="margin-top:0.3056in; font-size:17pt; margin-bottom:0.0417in; line-height:1.000000; font-weight:bold; keep-with-next:1; font-family:Arial"/>
<s type="P" name="Normal" followedby="Current Settings" props="font-family:Times New Roman; dom-dir:ltr; font-variant:normal; font-style:normal; margin-left:0pt; bgcolor:transparent; widows:2; color:000000; text-indent:0in; text-position:normal; margin-top:0pt; font-weight:normal; line-height:1.000000; font-size:12pt; text-decoration:none; margin-bottom:0pt; margin-right:0pt; text-align:left; font-stretch:normal"/>
<s followedby="Normal" name="Heading 2" basedon="Normal" type="P" props="margin-top:0.3056in; font-size:14pt; margin-bottom:0.0417in; line-height:1.000000; font-weight:bold; keep-with-next:1; font-family:Arial"/>
<s followedby="Normal" name="Heading 3" basedon="Normal" type="P" props="margin-top:0.3056in; font-size:12pt; margin-bottom:0.0417in; line-height:1.000000; font-weight:bold; keep-with-next:1; font-family:Arial"/>
<s followedby="Normal" name="Heading 4" basedon="Normal" type="P" props="margin-top:0.3056in; font-size:12pt; margin-bottom:0.0417in; line-height:1.000000; font-weight:bold; keep-with-next:1; font-family:Arial"/>
<s followedby="Normal" name="Contents 1" basedon="Normal" type="P" props="list-delim:%L.; list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Numbered List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Contents 2" basedon="Normal" type="P" props="list-delim:%L.; list-decimal:.; field-color:transparent; start-value:1; margin-left:1.0000in; field-font:NULL; line-height:1.000000; list-style:Numbered List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Contents 3" basedon="Normal" type="P" props="list-delim:%L.; list-decimal:.; field-color:transparent; start-value:1; margin-left:1.5000in; field-font:NULL; line-height:1.000000; list-style:Numbered List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Contents 4" basedon="Normal" type="P" props="list-delim:%L.; list-decimal:.; field-color:transparent; start-value:1; margin-left:2.0000in; field-font:NULL; line-height:1.000000; list-style:Numbered List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Numbered Heading 1" basedon="Heading 1" type="P" props="list-delim:%L.; field-color:transparent; start-value:1; margin-left:0.0in; field-font:Arial; text-indent:0.0in; line-height:1.000000; list-style:Numbered List; tabstops:0.299306in/L0"/>
<s followedby="Normal" name="Numbered Heading 2" basedon="Heading 2" type="P" props="list-delim:%L.; field-color:transparent; start-value:1; margin-left:0.0in; field-font:Arial; text-indent:0.0in; line-height:1.000000; list-style:Numbered List; tabstops:0.299306in/L0"/>
<s type="P" name="Square List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Square List; text-indent:-0.300000in"/>
<s type="P" name="Lower Roman List" basedon="Normal" followedby="Current Settings" props="list-delim:%L; list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Lower Roman List; text-indent:-0.300000in"/>
<s type="P" name="Diamond List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Diamond List; text-indent:-0.300000in"/>
<s type="P" name="Numbered List" followedby="Current Settings" props="list-delim:%L.; list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Numbered List; text-indent:-0.300000in"/>
<s type="C" name="Endnote Text" basedon="Normal" followedby="Current Settings" props="text-position:normal; line-height:1.000000"/>
<s type="C" name="Endnote Reference" basedon="None" followedby="Current Settings" props="text-position:superscript; line-height:1.000000; font-size:10pt"/>
<s type="P" name="Triangle List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Triangle List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Numbered Heading 3" basedon="Heading 3" type="P" props="list-delim:%L.; field-color:transparent; start-value:1; margin-left:0.0in; field-font:Arial; text-indent:0.0in; line-height:1.000000; list-style:Numbered List; tabstops:0.299306in/L0"/>
<s type="P" name="Dashed List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Dashed List; text-indent:-0.300000in"/>
<s type="P" name="Upper Roman List" basedon="Numbered List" followedby="Current Settings" props="list-delim:%L; list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Upper Roman List; text-indent:-0.300000in"/>
<s type="P" name="Heart List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Heart List; text-indent:-0.300000in"/>
<s followedby="Normal" name="Contents Header" basedon="Normal" type="P" props="margin-top:0.1667in; font-size:16pt; margin-bottom:0.0813in; font-weight:bold; line-height:1.000000; text-align:center; font-family:Arial; keep-with-next:1"/>
<s type="P" name="Upper Case List" basedon="Numbered List" followedby="Current Settings" props="list-delim:%L); list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Upper Case List; text-indent:-0.300000in"/>
<s type="P" name="Bullet List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Symbol; line-height:1.000000; list-style:Bullet List; text-indent:-0.300000in"/>
<s type="P" name="Hand List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Hand List; text-indent:-0.300000in"/>
<s type="C" name="Footnote Text" basedon="Normal" followedby="Current Settings" props="text-position:normal; line-height:1.000000; font-size:10pt"/>
<s type="P" name="Tick List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Tick List; text-indent:-0.300000in"/>
<s type="P" name="Lower Case List" basedon="Numbered List" followedby="Current Settings" props="list-delim:%L); list-decimal:.; field-color:transparent; start-value:1; margin-left:0.5000in; field-font:NULL; line-height:1.000000; list-style:Lower Case List; text-indent:-0.300000in"/>
<s type="P" name="Block Text" basedon="Normal" followedby="Current Settings" props="line-height:1.000000; margin-bottom:0.0813in; margin-left:1.0000in; margin-right:1.0000in"/>
<s type="C" name="Footnote Reference" basedon="None" followedby="Current Settings" props="text-position:superscript; line-height:1.000000; font-size:10pt"/>
<s followedby="Normal" name="Section Heading" basedon="Numbered Heading 1" type="P" props="list-delim:Section %L.; field-color:transparent; start-value:1; margin-left:0.0in; field-font:Arial; text-indent:0.0in; line-height:1.000000; list-style:Numbered List; tabstops:1.100000in/L0"/>
<s type="P" name="Implies List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Symbol; line-height:1.000000; list-style:Implies List; text-indent:-0.300000in"/>
<s type="P" name="Box List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Box List; text-indent:-0.300000in"/>
<s type="P" name="Star List" followedby="Current Settings" props="list-delim:%L; list-decimal:NULL; field-color:transparent; start-value:0; margin-left:0.5000in; field-font:Dingbats; line-height:1.000000; list-style:Star List; text-indent:-0.300000in"/>
<s type="P" name="Plain Text" basedon="Normal" followedby="Current Settings" props="font-family:Courier New; line-height:1.000000"/>
<s followedby="Normal" name="Chapter Heading" basedon="Numbered Heading 1" type="P" props="list-delim:Chapter %L.; field-color:transparent; start-value:1; margin-left:0.0in; field-font:Arial; text-indent:0.0in; line-height:1.000000; list-style:Numbered List; tabstops:1.100000in/L0"/>
</styles>
<pagesize pagetype="A4" orientation="portrait" width="210.000000" height="297.000000" units="mm" page-scale="1.000000"/>
<section xid="6">
<p style="Heading 1" xid="7" props="text-align:center"><c props="lang:en-GB">Notes on Graphics Shaping Functions</c></p>
<p xid="1" props="text-align:center"><c props="lang:en-GB">Tomas Frydrych &lt;tomasfrydrych@yahoo.co.uk&gt;</c></p>
<p xid="2" props="text-align:center"><c props="lang:en-GB">Dec 4, 2004</c></p>
<p xid="3" props="text-align:center"></p>
<p style="Heading 2" xid="5"><c props="lang:en-GB">Complex Scripts</c></p>
<p style="Normal" xid="102"><c props="lang:en-GB">Some languages require that extra processing is done on text before it can be output on screen. This document addresses two particular issues: bidirectional reordering, and shaping, and the AbiWord API for interfacing with external libraries for complex script processing.</c></p>
<p style="Heading 3" xid="104"><c props="lang:en-GB">Bidirectional reordering</c></p>
<p style="Normal" xid="106"><c props="lang:en-GB">Some languages are written from left to right (LTR) others from right to left (RTL). When the two are mixed together (bidirectional text), things get messy. In particular, certain characters are not clearly LTR or RTL -- their directionality depends on their context. The Unicode standard describes an algorithm for determining the order of characters on screen for a given sequence of characters.</c></p>
<p style="Heading 3" xid="107"><c props="lang:en-GB">Shaping</c></p>
<p style="Normal" xid="109"><c props="lang:en-GB">In some languages, such as Arabic, a character has a number of different shapes depending on the characters it connects to, and before text can be output on screen, correct shape has to be selected for each character in the text; this process is called shaping</c></p>
<p style="Normal" xid="103"></p>
<p style="Normal" xid="101"><c props="lang:en-GB">The AbiWord layout engine implements bidirectional reordering of text according to the Unicode bidi algorithm (using the fribidi library). In addition, the base GR_Graphics class also implements very basic shaping for complex scripts. However, the capabilities of the built-in shaper are extremely limited -- it is only intended for platforms which do not provide more sophisticated shaping engine; rather, the platform graphics class should make use of any shaping services the platform provides. In order to take advantage of the platform services, the platform graphics class needs to implement the virtual fucntions and abstract classes described in this document.</c></p>
<p style="Normal" xid="91"></p>
<p style="Normal" xid="92"><c props="lang:en-GB">Shaping and bidirectional reordering are closely tied together. The whole process of processing complex text consists of three stages: itemisation, reordering and shaping.</c></p>
<p style="Heading 3" xid="93"><c props="lang:en-GB">Itemitisation</c></p>
<p style="Normal" xid="100"><c props="lang:en-GB">Itemisation is a process in which the shaper divides a sequence of characters into a subsequences that have consistent properties for the purposes of reordering and shaping.</c></p>
<p style="Heading 3" xid="95"><c props="lang:en-GB">Reordering</c></p>
<p style="Normal" xid="97"><c props="lang:en-GB">Reordering is a process by which the items created in the itemisation stage are put into a sequence for direct output on the screen. This consists of two separate steps: reordering of individual items, and reording of text within each item; the former is always done by the AW layout engine, the latter is done by the shaper.</c></p>
<p style="Heading 3" xid="112"><c props="lang:en-GB">Shaping</c></p>
<p style="Normal" xid="99"><c props="lang:en-GB">Shaping is a process by which the Unicode text is converted into a sequence of glyphs to be output to the screen; this is done by the shaper.</c></p>
<p style="Normal" xid="113"></p>
<p style="Normal" xid="114"><c props="lang:en-GB">The internal workings of a shaper will vary from implementation to implementation. AbiWord's Graphics class provides an abstract API, which allows for the details of how the shaping is achieved to be completely opaque the the AbiWord layout classes.</c></p>
<p style="Heading 2" xid="115"><c props="lang:en-GB">Shaping API Classes</c></p>
<p style="Heading 3" xid="117"><c props="lang:en-GB">GR_Item</c></p>
<p style="Normal" xid="120"><c props="lang:en-GB">This is an abstract class that describes an item of text and is passed to the shaper. Each platform needs to implement a derived class that would hold item information required by the specific shaper.</c></p>
<p style="Heading 3" xid="121"><c props="lang:en-GB">GR_Itematization</c></p>
<p style="Normal" xid="123"><c props="lang:en-GB">A wrapper class for a set of items, passed to the itemization function (see below).</c></p>
<p style="Heading 3" xid="124"><c props="lang:en-GB">GR_RenderInfo</c></p>
<p style="Normal" xid="126"><c props="lang:en-GB">Abstract class that encapsulates shaping information for an item of text. The contents of this class are produced by the shaper and are later passed to the rendering routines. Each platform has to implement a derrived class, holding whatever information it needs to pass between the shaper and the rendering (drawing) routines.</c></p>
<p style="Normal" xid="127"></p>
<p style="Normal" xid="128"><c props="lang:en-GB">This class contains several virtual methods that allow rendered items to be split, appended and cut. </c></p>
<p style="Heading 4" xid="180" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">bool GR_RenderInfo::append(GR_RenderInfo &amp;ri, bool bReverse)</c></p>
<p style="Normal" xid="182"><c props="lang:en-GB">The purpose of this method is to append the contents of *this and of ri. bReverse is set if the items are in RTL order.</c></p>
<p style="Normal" xid="185"></p>
<p style="Normal" xid="184"><c props="lang:en-GB">If the graphics class is not able to append items, this function should return false; this will force the text in question to be scheduled for reshaping.</c></p>
<p style="Heading 4" xid="183" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">bool cut(UT_uint32 offset, UT_uint32 len, bool bReverse)</c></p>
<p style="Normal" xid="186"><c props="lang:en-GB">This method should remove a segment of length len starting at offset offset from the item; bReverse is set if the item is in RTL order. If the function is not able to remove segments from the item, it should return false; this forces the text in question to be scheduled for reshaping.</c></p>
<p style="Heading 4" xid="187" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">bool split (GR_RenderInfo *&amp;pri, bool bReverse)</c></p>
<p style="Normal" xid="181"><c props="lang:en-GB">This function should split the item represented by *this into two parts and return the second part in pri; bReverse indicates that the item is in RTL order; the offset of the split is set in this-&gt;m_iOffset.</c></p>
<p style="Normal" xid="188"><c props="lang:en-GB">If the fuction cannot split the item, it should indicate it be returning false. However, if pri == NULL, the function has to allocate a new instance of GR_*RenderInfo and set pri to it. In all cases, the function has to make copy of this-&gt;m_pItem in pri-&gt;m_pItem.</c></p>
<p style="Heading 3" xid="131"><c props="lang:en-GB">GR_ShapingInfo</c></p>
<p style="Normal" xid="136"><c props="lang:en-GB">This class encapsulates information that is passed down to the shapper; this class is not abstract and should not be overriden by platform version. Among other things, this class holds a pointer to GR_Item.</c></p>
<p style="Heading 2" xid="137"><c props="lang:en-GB">GR_Graphics complex scripts-related virtual methods</c></p>
<p style="Heading 3" xid="133"><c props="lang:en-GB">bool itemize(UT_TextIterator &amp; text, GR_Itemization &amp; I);</c></p>
<p style="Normal" xid="134"><c props="lang:en-GB">This method has to produce set of items describing the Unicode text represented by the text iterator.</c></p>
<p style="Heading 3" xid="12"><c props="lang:en-GB">bool shape(GR_ShapingInfo &amp; si, GR_RenderInfo *&amp; ri);</c></p>
<p style="Normal" xid="16" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">This method produces a platform specific instance of GR_*RenderInfo for the text represented by GR_ShapingInfo si.</c></p>
<p style="Heading 3" xid="138"><c props="lang:en-GB">void renderChars(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="140" props="font-family:Times New Roman; text-decoration:none; dom-dir:ltr; color:000000; font-size:12pt; font-weight:normal; text-position:normal; text-align:left; font-style:normal"><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-GB">This is the function responsible for drawing on screen the text represented by GR_RenderInfo ri. It should be noted that renderChars() can be asked to output only a segment from the text which is represented by ri (see prepareToRenderChars())</c></p>
<p style="Heading 3" xid="141"><c props="lang:en-GB">void prepareToRenderChars(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="142" props="font-family:Times New Roman; dom-dir:ltr; font-style:normal; margin-left:0.0000in; lang:en-GB; text-align:left; text-indent:0.0000in; text-position:normal; margin-top:0.0000in; font-weight:normal; line-height:1.000000; margin-bottom:0.0000in; font-size:12pt; margin-right:0.0000in; text-decoration:none"><c props="lang:en-GB">This function is called imediately before renderChars() and is passed the same input GR_RenderInfo ri. The purpose of this function is to do any pre-processing that renderChars() might require. For example, renderChars() might be called inside a loop, asked to draw the text represented by ri in several segments (as when we draw selection, and need to change colour of text and the background). However, it might be possible and desirable to take some processing outside that loop and do it only once for the whole text represented by ri; such processing should take place in prepareToRenderChars(), which will be called outwith the loop.</c></p>
<p style="Heading 3" xid="21"><c props="lang:en-GB">void appendRenderedCharsToBuff(GR_RenderInfo &amp; ri, UT_GrowBuf &amp; buf) const;</c></p>
<p style="Normal" xid="143" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">This function is included for legacy reasons and working implementation does not have to be provided; however, the platform should provide dummy implementation containing a not-implemented assert if it does not provide a working implementation.</c></p>
<p style="Heading 3" xid="144"><c props="lang:en-GB">void measureRenderedCharWidths(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="145" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">This function is to measure the (shaped) text represented by GR_RenderInfo ri, what exactly is involved in this, and how the text metrics is stored is up to the platform implemenation. The actual metrics of text is obtained by subsequent calls to getTextWidth() described below.</c></p>
<p style="Heading 3" xid="25"><c props="lang:en-GB">bool canBreak(GR_RenderInfo &amp; ri, UT_sint32 &amp;iNext, bool bAfter);</c></p>
<p style="Normal" xid="146" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Determines if text can be legally broken (for linebreaking purposes) at given position. ri.m_pText contains an iterator which is positioned at the start of the item represented by ri and it has its upper limit set so as not to advance beyond the end of the item. The offset of the character at which the break is questioned is in ri.m_iOffset, and ri.m_iLength contains the length of the item (in characters). bAfter indicates whether the caller is asking for break before or after the the given character.</c></p>
<p style="Normal" xid="176" props="text-align:left; dom-dir:ltr"></p>
<p style="Normal" xid="147" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">If break is not possible at the requested position, the function may indicate to the caller where in the item the next legal break point is by setting iNext (as an offset from the start of the item); if the fuction does not know where the next break point is, it should set iNext to -1.</c></p>
<p style="Heading 3" xid="39"><c props="lang:en-GB">bool needsSpecialCaretPositioning(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="148" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">This function indicates whether the item represented by ri requires special positioning of the caret (in some lanaguages, such as Thai, not all caret positions are valid).</c></p>
<p style="Heading 3" xid="43"><c props="lang:en-GB">UT_uint32 adjustCaretPosition(GR_RenderInfo &amp; ri, bool bForward);</c></p>
<p style="Normal" xid="51" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-GB">This function should adjusts caret position if given script restricts where caret can be placed. T</c><c props="font-family:Times New Roman; font-size:12pt; lang:en-GB; text-position:normal; font-weight:normal; font-style:normal; text-decoration:none">he caller has to set initial position of the caret within the run in ri.m_iOffset, overall length of the item in ri.m_iLength and provide a text iterator over the text of the run in ri.m_pText. bForward indicates if the caret is moving forward or backward. The return value is the adjusted offset</c></p>
<p style="Normal" xid="153" props="margin-top:0.0000in; margin-left:0.0000in; text-indent:0.0000in; dom-dir:ltr; margin-bottom:0.0000in; line-height:1.000000; text-align:left; margin-right:0.0000in"></p>
<p style="Heading 3" xid="52" props="lang:en-GB"><c props="lang:en-GB">void adjustDeletePosition(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="60" props="font-family:Times New Roman; text-decoration:none; dom-dir:ltr; color:000000; font-size:12pt; font-weight:normal; text-position:normal; text-align:left; font-style:normal"><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-GB">This function adjusts position for delete if given script restricts deletion to character clusters. </c><c props="font-family:Times New Roman; font-size:12pt; lang:en-GB; text-position:normal; font-weight:normal; font-style:normal; text-decoration:none">The caller has to set initial position within the item where deletion is to happen in ri.m_iOffset, overall length to be deleted in ri.m_iLength and provide a text iterator over the text of the run in ri.m_pText. On return ri.m_iOffset should contain the adjusted (item-relative) position and ri.m_iLength the adjusted length of the delete (for example, the language rules might require that delete of 3 characters at offset 2 in the item, results in actual delete of 4 characters starting at offset 1).</c></p>
<p style="Heading 3" xid="158" props="lang:en-GB"><c props="lang:en-GB">bool nativeBreakInfoForRightEdge();</c></p>
<p style="Normal" xid="66" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-GB">The AbiWord line breaking was designed so as to look for breaks at the right edge of a character, </c><c props="font-family:Times New Roman; font-size:12pt; lang:en-GB; text-position:normal; font-weight:normal; font-style:normal; text-decoration:none">ii.e., the character that can break is included with the left part of the split run. The Uniscribe library, however, holds breaking info for left edge, and sometimes it is useful to know what system we are dealing with for performance reasons.</c></p>
<p style="Heading 3" xid="163"><c props="lang:en-GB">UT_sint32 resetJustification(GR_RenderInfo &amp; ri, bool bPermanent);</c></p>
<p style="Normal" xid="164" props="font-family:Times New Roman; font-size:12pt; dom-dir:ltr; color:000000; lang:en-GB; font-weight:normal; text-position:normal; text-align:left; font-style:normal; text-decoration:none"><c props="lang:en-GB">If the character advances in this run have been adjusted due to justification, call to this function should reset them back to the regular character advances. bPermanent indicates whether this reset is temporary for the benefit of the linebreaking routines, or whether it is permanent (whether the function handles the two differently depends on what is involved in the reset).</c></p>
<p style="Heading 3" xid="165" props="lang:en-GB"><c props="lang:en-GB">UT_sint32 countJustificationPoints(const GR_RenderInfo &amp; ri) const;</c></p>
<p style="Normal" xid="166" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Determine number of points between which any justification amount can be divided. This function has to take into account ri.m_bLastOnLine; if set, any justification points after last meaningful character in the item are to be disregarded.</c></p>
<p style="Heading 3" xid="167"><c props="lang:en-GB">void justify(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="168" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Adjust character advances using ri.m_iJustificationPoints and ri.m_iJustificationAmount.</c></p>
<p style="Heading 3" xid="70"><c props="lang:en-GB">UT_uint32 XYToPosition(const GR_RenderInfo &amp; ri, UT_sint32 x, UT_sint32 y) const;</c></p>
<p style="Normal" xid="169" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Translate point &lt;x,y&gt; (in layout units relative to the screen coords of the item) to a position in the item (return value is the offset into the item, relative to the start of the item).</c></p>
<p style="Heading 3" xid="170"><c props="lang:en-GB">void positionToXY(const GR_RenderInfo &amp; ri, UT_sint32&amp; x, UT_sint32&amp; y, UT_sint32&amp; x2, UT_sint32&amp; y2, UT_sint32&amp; height, bool&amp; bDirection) const;</c></p>
<p style="Normal" xid="171" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Translate character offset in ri.m_iOffset (relative to the start of the item) to coords (in layout units, relative to screen position of the item).</c></p>
<p style="Heading 3" xid="76"><c props="lang:en-GB">UT_sint32 getTextWidth(GR_RenderInfo &amp; ri);</c></p>
<p style="Normal" xid="172" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">Measure the width of segment of text from item represented by ri, starting at offset ri.m_iOffset, and of length ri.m_iLength.</c></p>
<p style="Heading 3" xid="78"><c props="lang:en-GB">const UT_VersionInfo &amp; getVersion() const;</c></p>
<p style="Normal" xid="174" props="text-align:left; dom-dir:ltr"><c props="lang:en-GB">This function needs only to be implemented by graphics classes that are plugins.</c></p>
<p style="Heading 3" xid="173"><c props="lang:en-GB">void drawChars();</c></p>
<p style="Normal" xid="178"><c props="lang:en-GB">When the graphics class provides renderChars() method, the drawChars() method is only used to draw static text, and hence, its performance is less critical. The drawChars() method has to carry out the entire itemize/reorder/shape process on the Unicode text passed to it.</c></p>
<p style="Normal" xid="177" props="text-align:left; dom-dir:ltr"></p>
<p style="Normal" xid="179" props="text-align:left; dom-dir:ltr"></p>
</section>
</abiword>
