
[ NOTE -- as of 26 January 1999, this file is utter fiction.  Ignore
          everything this document says.]

[ NOTE -- as of 4 December, this file is terribly, terribly out-of-date
          and should be gutted and/or deleted as soon as possible.]

[ NOTE -- as of 25 September, this file is terribly out-of-date :-)
          This document gives a brief summary of the various classes
          that we had at the time it was written.  Many of these
          classes still exist, many still exist but have been renamed,
          and many have been completely replaced.  Furthermore, new
          classes have not been added to this document.  We've left
          this document here because it does provide good background
          information on what we have.  Information on document
          structure is the most obsolete (we've moved from a GapBuffer
          to a PieceTable), but information on the formatter is still
          reasonably OK.  This file will be updated shortly (really). ]

[ NOTE -- as of 21 August, this file is not completely up-to-date.  As
far as I can tell from a quick skim, the information here is accurate,
but there are pieces missing. ]

AbiWord Design Notes
--------

This file is intended to given design information regarding the
architecture of AbiWord. Its target audience consists primarily of
programmers who wish to participate in the project.

A history of changes to this file appears at the end, automatically
generated by CVS/RCS.

The core engine of AbiWord is in abi/src/wp/guts/xp.  We called the
directory 'guts' because 'core' would look like a UNIX core file. :-)

In this directory, you should find all of the classes which are used
to represent a document and its formatted representation.  All files
here are prefixed with "dg_", to indicate their membership in the
guts module.  Classes defined here are prefixed with DG_ if they are
public (usable outside the guts module), and dg_ if they are private.

Here is a brief description of each major class:

--DG_Document

This is the root class for representing a document.  This class does
not contain any layout information or formatted representation.
Rather, it simply is the representation of a document file on disk.
After reading or importing a document file, a DG_Document is the
result.  To export or save a document file, a DG_Document is all you
need.

--DG_Section

A Section is a grouping of paragraphs within the document, with
certain attributes attached to the group.  Most imprtantly, a section
implies a specific layout of the columns which are used for the
paragraphs within that section.  For example, one might want a
document with an abstract at the top of the first page, spanning the
full width of the usable area on that page.  Then, the actual content
of the document might follow, but the layout might switch to a
two-column layout.  Using this example, the abstract would be in one
section, and that section would specify a simple one-column layout.
The document content would be in the second section, specifying a
two-column layout.  All paragraphs within a section must use the same
column layout, which we refer to as a ColumnModel.

--DG_ColumnModel

A ColumnModel describes the type and layout of columns which are to be
used for a given Section.  Currently, ColumnModel is reasonably
simple.  More powerful capabilities will be added to this class in the
future.

--DG_DocLayout

A DocLayout is the object which is responsible for managing the
formatting information for a given Document.  The formatted
representation of a document is distinct from its structure.  We often
refer to this formatted representation of a document as the "layout
hierarchy", and the DocLayout object is the root of this hierarchy.
You can create multiple DocLayouts for each Document.  Right after you
import a file and get a DG_Document to work with, the next thing to do
is probably to create a DocLayout for that Document.

--DG_Graphics

A DocLayout, and all of the classes in its hierarchy, must be
specifically tied to a particular graphical context.  This is
intuitive -- you cannot format a document until you know the
graphical properties of the medium for which you are formatting.  So,
to create a DocLayout object, you must pass a DG_Graphics object into
the constructor.

A DG_Graphics is responsible for providing fonts and their dimensions.
It must be able to give the underlying resolution of the graphical
context it represents.  It also contains drawing primitives, so that
the DocLayout can use the same Graphics object for calculations and
for rendering.

DG_Graphics is abstract.  You must implement concrete subclasses of
DG_Graphics in order to create implementations of a particular
graphical environment.  For example, DG_Win32Graphics is a subclass of
DG_Graphics which encapsulates the Win32 graphics API.  Other
subclasses will be used to represent other graphical contexts, such as
X11, Macintosh, PostScript, or ASCII text output.

--DG_SectionLayout

A SectionLayout is used to manage the layout process for a specific
Section.  Since a Section can span multiple columns or pages, a
SectionLayout is the object which keeps track of the columns and pages
for its section.

--DG_BlockLayout

A BlockLayout is used to manage the layout process for a specific
paragraph, as represented by a block node in the document tree.  There
is an explicit analogy between Section/SectionLayout and
Block/BlockLayout.  A Block may span multiple columns, so a
BlockLayout is used to keep track of the space being used by the
Block, potentially in more than one column.

--DG_Page

A DG_Page represents a specific Page in the formatted representation
of a document.  A DocLayout has a list of DG_Page objects.

A Page is a spatial object in the layout hierarchy.  It has a specific
size and shape.  However, unlike most objects in the layout hierarchy,
a Page is always measured in physical units, irrespective of the
resolution of the Graphics object for which a DocLayout is targeted.
Basically, a Page represents a physical object (a piece of paper), so
its physical size is fixed.

--DG_SectionPiece

A SectionLayout manages the layout of a Section by requesting space
from Pages as needed.  When a Page grants space to a SectionLayout,
that space is called a SectionPiece, because it is a piece of a
SectionLayout.  It is the responsibility of the SectionLayout to
create the proper Column objects within that SectionPiece.

--DG_Column

A Column is a very important class in the architecture of AbiWord.  It
represents exactly what you think it does -- a column into which text
can be flowed.  However, an AbiWord column need not be rectangular in
shape.

In fact, DG_Column is actually an abstract class.  Concrete subclasses
of DG_Column are used to represent columns with a specific shape.
Currently, we have implemented just two: DG_BoxColumn (a rectangular
column, the most common case), and DG_CircleColumn (a circular
column).  In the future, we intend to implement columns with other
shapes, including a polygon column and perhaps a column bounded by a
Bezier curve.

--DG_BlockPiece

A BlockLayout coordinates the formatting of a given block, and it does
so by requesting space from Columns in which it can place its lines.
When a Column grants space to a Block, we call that space a
BlockPiece.

--DG_Line

A Line is a line.  It represents one line of formatted content.  A
Line is always rectangular.

--DG_Run

// TODO

--DG_LineBreaker

A LineBreaker encapsulates a line breaking algorithm (see "Strategy"
in the excellent book, "Design Patterns").  This class is abstract.
Concrete subclasses are used to implement specific line breaking
algorithms.  Currently, the only LineBreaker we have implemented is a
greedy algorithm, which simply puts as much text on each line as will
fit.  It is called DG_SimpleLineBreaker.  In the future, we will want
to implement other choices here, including perhaps the TeX line
breaking algorithm, algorithms which make use of hyphenation engines,
algorithms for Japanese line breaking rules, and so on.

The design of LineBreakers is specifically done so that the
LineBreaker can remain ignorant of the fact that its paragraph may be
split across multiple columns.  Basically, you create a LineBreaker,
and you tell it run its algorithm on a given BlockLayout.  It iterates
over all of the Runs in that Block, an places them on Lines as it sees
fit.  For each Line, it requests space from the BlockLayout.  A chain
of space requests ensues, as the BlockLayout must request space from
the SectionLayout which may need to request space from a Page.
Eventually, the space request is satisfied, and the LineBreaker is
merely told the width of the area it has to work with.  That area
corresponds to a piece of space within some BlockPiece, within a
specific Column, inside a SectionPiece, on a certain Page.

--DG_Property

AbiWord is not compliant with CSS2 or XSL, but it uses CSS2 property
names, and it uses a design concepts from CSS2 whenever possible.
DG_Property is used to encapsulate a specific property name.  The
value of a property can be queried from a DG_ElementNode.

--------
-- The layout hierarchy.

   A DocLayout contains Pages
   A Page contains SectionPieces
   A SectionPiece contains Columns
   A Column contains BlockPieces
   A BlockPiece contains Lines.
   A Line contains Runs.

-- Things don't know where they are

An important design rule we've used is that within the layout
hierarchy, spatial objects do not know their position.  Rather, their
parent knows their position.  Furthermore, their position is always
stored relative to the origin of the parent.  So, for example, a
BoxColumn knows its height and width, but it considers its origin to
be at (0,0).  Only its parent SectionPiece knows the X and Y offset of
the upper-left corner of the column.

This design allows us to move something without letting it know.  As
long as its size and shape don't change, an object can be moved
somewhere else without the need to recalculate the positions of
anything inside it.

--------------------------------
--------------------------------
--------------------------------
--------------------------------
$Log$
Revision 1.6  1999/01/26 20:16:36  eric
Here's a BIG checkin:

I've rewritten a LOT of the layout engine, fixing
many problems, as well as laying the groundwork for
more fixes and new features.  Info you might want
to know:

1.  The column model is code completely different now.
Support for non-rectangular columns is gone, and the
new multiple-column support is reasonably simplistic.

2.  Multiple sections with differing column models is
partially functional.  See the new version of Interview.abw
for a sample of how this can work.

3.  Old documents will NOT read properly.  The column model
tags choke the parser.

4.  Multiple section support has problems.  Deleting across
a section boundary will crash.  There is no way to insert
a section boundary.  There is no way to change the attributes
of a section.  These things will come...

5.  The beginnings of some widow-orphan control code have been
added.  Not done yet.

6.  I have NOT yet update the redraw code for find/replace as
I promised to Shaw.  Coming soon.

7.  Bug 72 should be fixed now.  The layout engine knows how to
delete empty pages.

8.  Bug 93 should be fixed now.  Things flow back and forth between
columns with relative ease.

9.  Bug 136 should be fixed now.  Editing of centered text should
no longer be a problem.

10.  I still unhappy about the fact that a single character
addition to the end of a line causes that entire line to be
redrawn.

11.  I do not yet know if this will build and work on Linux.
Right after this commit, I'll go check it out there.  I expect
no problems.

12.  I added a programmer guidelines document to src/docs.
As we become more of a Bazaar, we'll need to give more of this
kind of help to outside developers.

13.  Several files have been deleted, and several have been added.

14.  You'll need a full rebuild of the whole tree.  :-)

Revision 1.5  1998/12/05 04:29:58  jeff
Updated build instructions.
Started work on a document to describe our document format.

Revision 1.4  1998/09/25 16:26:09  jeff
Added 9/25 update note.

Revision 1.3  1998/08/19 02:47:25  eric
added some code to merge two blocks together.  Used when you go to the
end of a block and hit the forward-delete key.

also fixed the blockpiece code to allow deleting of a blockpiece from
a column, and to allow a blockpiece with no lines in it.  This is a first
step toward allowing a paragraph with nothing in it.

Revision 1.2  1998/08/12 15:41:14  eric
Partial work updating the README files and build instructions in the tree.

Revision 1.1  1998/07/21 14:25:38  eric
Initial version of design notes.

--------------------------------
--------------------------------
--------------------------------
--------------------------------
