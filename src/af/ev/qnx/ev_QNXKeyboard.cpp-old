/* AbiSource Program Utilities
 * Copyright (C) 1998 AbiSource, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
 * 02111-1307, USA.
 */
 

#include "ut_types.h"
#include "ut_assert.h"
#include "ut_debugmsg.h"
#include "ev_EditBinding.h"
#include "ev_EditEventMapper.h"
#include "ev_EditMethod.h"
#include "xav_View.h"
#include "ev_NamedVirtualKey.h"
#include "ev_QNXKeyboard.h"
#include <stdio.h>

//////////////////////////////////////////////////////////////////

static EV_EditBits s_mapVirtualKeyCodeToNVK( PhKeyEvent_t *keyevent);
static UT_Bool s_isVirtualKeyCode( PhKeyEvent_t * keyevent);
static int s_GetKeyFromEvent(PhKeyEvent_t *keyevent);

//////////////////////////////////////////////////////////////////

ev_QNXKeyboard::ev_QNXKeyboard(EV_EditEventMapper* pEEM)
	: EV_Keyboard(pEEM)
{
}

/*
 This will get called by the static callback handler which 
 is attached ... elsewhere in the Frame
*/
UT_Bool ev_QNXKeyboard::keyPressEvent(AV_View* pView,
					PtCallbackInfo_t* e)
{
	PhKeyEvent_t *keyevent;

	/*if (e->event->type != Ph_EV_KEY &&
	      e->event->subtype != Ph_EV_KEY_NORMAL
	*/

	if (!(keyevent = (PhKeyEvent_t *)PhGetData(e->event)))
		return(UT_FALSE);

	if (!(keyevent->key_flags & KEY_DOWN)) {
		return(UT_FALSE);
	}

	EV_EditBits state = 0;
	EV_EditEventMapperResult result;
	EV_EditMethod * pEM;

	//If required compare key_flags w/ KEY_DOWN, KEY_REPEAT, KEY_SYM_VALID ..
#if 0
	if (keyevent->key_mods & KEYMODBIT_SHIFT)
		state |= EV_EMS_SHIFT;
	if (keyevent->key_mods & KEYMODBIT_CTRL)
		state |= EV_EMS_CONTROL;
	if (keyevent->key_mods & KEYMODBIT_ALT)
		state |= EV_EMS_ALT;
#endif
	//UT_DEBUGMSG(("KeyPressEvent: keyval=%04lx state=%04lx\n",e->keyval,state));

	if (s_isVirtualKeyCode(keyevent))
	{
		EV_EditBits nvk = s_mapVirtualKeyCodeToNVK(keyevent);
		printf("KB: Virtual key scancode 0x%x \n", keyevent->key_cap);
		printf("KB: Using nvk 0x%x ignore is 0x%x \n", nvk, EV_NVK__IGNORE__);
		switch (nvk)
		{
		case EV_NVK__IGNORE__:
			return UT_FALSE;
		default:
			result = m_pEEM->Keystroke((UT_uint32)EV_EKP_PRESS|state|nvk,&pEM);

			switch (result)
			{
			case EV_EEMR_BOGUS_START:
				// If it is a bogus key and we don't have a sequence in
				// progress, we should let the system handle it
				// (this lets things like ALT-F4 work).
				return UT_FALSE;
				
			case EV_EEMR_BOGUS_CONT:
				// If it is a bogus key but in the middle of a sequence,
				// we should silently eat it (this is to prevent things
				// like Control-X ALT-F4 from killing us -- if they want
				// to kill us, fine, but they shouldn't be in the middle
				// of a sequence).
				return UT_TRUE;
				
			case EV_EEMR_COMPLETE:
				UT_ASSERT(pEM);
				invokeKeyboardMethod(pView,pEM,0,0); // no char data to offer
				return UT_TRUE;
				
			case EV_EEMR_INCOMPLETE:
				return UT_TRUE;
				
			default:
				UT_ASSERT(0);
				return UT_TRUE;
			}
		}
	}
	else
	{
		UT_uint16 charData;

		charData = s_GetKeyFromEvent(keyevent);
		//numbytes = PhKeyToMb(char *buffer, keyevent);
		printf("KB: KeyPressEvent [%c] [%d] State 0x%x \n", 
					charData, charData, state);
		result = m_pEEM->Keystroke(EV_EKP_PRESS|state|charData,&pEM);

		switch (result)
		{
		case EV_EEMR_BOGUS_START:
			// If it is a bogus key and we don't have a sequence in
			// progress, we should let the system handle it
			// (this lets things like ALT-F4 work).
			return UT_FALSE;
			
		case EV_EEMR_BOGUS_CONT:
			// If it is a bogus key but in the middle of a sequence,
			// we should silently eat it (this is to prevent things
			// like Control-X ALT-F4 from killing us -- if they want
			// to kill us, fine, but they shouldn't be in the middle
			// of a sequence).
			return UT_TRUE;
			
		case EV_EEMR_COMPLETE:
			UT_ASSERT(pEM);
			invokeKeyboardMethod(pView,pEM,&charData,1); // no char data to offer
			return UT_TRUE;
			
		case EV_EEMR_INCOMPLETE:
			return UT_TRUE;
			
		default:
			UT_ASSERT(0);
			return UT_TRUE;
		}
	}

	return UT_FALSE;
}

static UT_Bool s_isVirtualKeyCode(PhKeyEvent_t *keyevent)
{
	int key;

#if 0
	switch (keyevent->key_cap) {
	case KEYCODE_SPACE:
		return(UT_FALSE);
	}
#endif

	if (keyevent && (key = PhTo8859_1(keyevent)) == -1)
		return(UT_TRUE);

	if (key == ' ')
		return(UT_TRUE);

	return UT_FALSE;
}

static EV_EditBits s_mapVirtualKeyCodeToNVK(PhKeyEvent_t *keyevent)
{
	//Put this into an array ...
	switch (keyevent->key_cap) {
	case KEYCODE_PAUSE:
	case KEYCODE_SCROLL_LOCK:
	case KEYCODE_PRINT:
	case KEYCODE_SYSREQ:
	case KEYCODE_BREAK:
		break;

	case KEYCODE_ESCAPE:
		return(EV_NVK_ESCAPE);
	case KEYCODE_SPACE:
		printf("Retruning NVK_SPACE \n");
		return(EV_NVK_SPACE);
	case KEYCODE_BACKSPACE:
		return(EV_NVK_BACKSPACE);
	case KEYCODE_TAB:
		return(EV_NVK_TAB);
	case KEYCODE_RETURN:
		return(EV_NVK_RETURN);
	}
	return EV_NVK__IGNORE__;
}

static int s_GetKeyFromEvent(PhKeyEvent_t *keyevent)
{
	//Put this into an array ...
#if 0
	switch (keyevent->key_cap) {
	case KEYCODE_SPACE:
		return(' ');
	}
#endif

	return(PhTo8859_1(keyevent));
}

